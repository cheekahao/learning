# 编译原理

>《编译系统透视：图解编译原理》读书笔记

## C程序的运行式结构

C程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。

以下面的程序为例：

```c
int fun(int a, int b);
int m = 10;
int main() {
    int i = 4;
    int j = 5;
    m = fun(i, j);
    return 0;
}
int fun(int a,int b) {
    int c=0;
    c=a+b;
    return c;
}
```

### 程序加载时的内存概况

运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。

![内存区域](//img.haozhenjia.com/blog/code_memory.jpg)

其中，**代码区**装载了程序所对应的机器指令；全局变量`m`的数值装载在**静态数据区**中；**动态数据区**加载程序运行过程中产生的数据。

程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。

`CPU`中有三个寄存器，分别是`eip`、`ebp`和`esp`。

`eip`永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指令后跳转到指定的位置。

`ebp`和`esp`用来管控栈空间，`ebp`指向栈底，`esp`指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。

`eip`指向`main`函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。

### 程序运行过程中的内存变化

程序开始执行`main`函数第一条指令(`call`指令)，`eip`自动指向下一条指令。第一条指令的执行，致使`ebp`的地址值被保存在栈中，保存的目的是本程序执行完毕后，`ebp`还能返回现在的位置，复原现在的栈。

随着`ebp`地址值的压栈，`esp`自动向栈顶方向移动，它将永远指向栈顶。

接下来，开始构建`main`函数自己的栈，`ebp`原来指向的地址值已经被保存了，此时和`esp`是重叠的，用来看管main函数的栈底。

```
push ebp; 保存当前ebp
mov ebp, esp; EBP设为当前堆栈指针
sub esp, xxx; 预留xxx字节给函数临时变量.
```