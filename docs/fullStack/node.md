# Node

> 参考文章[Node-内存管理和垃圾回收](https://juejin.im/post/6844903837912973326)

## 垃圾回收

由于`Node`是基于`V8`构建的，而`V8`对于内存的使用有一定的限制。在默认情况下`64`位的机器大概可以使用`1.4G`，而`32`位则为`0.7G`。

限制内存大小的原因有两个方面：

* `V8`一开始用于浏览器， 这样的内存大小绰绰有余
* 垃圾回收机制。垃圾回收会暂停`JS`的运行，内存过大会导致垃圾回收的时间变长，从而导致`JS`暂停的时间过长

在启动`Node`服务时，可以手动设置内存的大小：

```
node --max-old-space-size=768 // 设置老生代， 单位为MB  
node --max-semi-space-size=64 // 设置新生代， 单位为MB
```

在`Node`环境中，可以通过`process.memoryUsage()`来查看内存分配：

```
rss（resident set size）：所有内存占用，包括指令区和堆栈
heapTotal：V8引擎可以分配的最大堆内存，包含下面的heapUsed
heapUsed：V8引擎已经分配使用的堆内存
external： V8管理C++对象绑定到JavaScript对象上的内存
```

对于大文件的操作通常会使用`Buffer`，主要是因为Node中可以使用内存小，而`Buffer`是堆外内存即`external`

## V8的内存分代

`V8`的内部采用两种垃圾回收算法，分别针对生存周期较短和生存周期较长的两种对象。

**新生代**

主要存放生存周期较短的对象，具有`From`和`To`两个空间`semispace`。在分配内存的时候将内存分配给`From`空间， 当垃圾回收的时候，检查`From`空间存活的对象(广度优先算法)并复制到`To`空间，然后清空`From`空间，再互相交换`From`和`To`空间的位置，使`To`空间变为`From`空间。

该算法缺陷是有一半的空间一直闲置着并且需要复制对象，但新生代本身具有的内存比较小并且其分配的对象都是生存周期比较短的对象，所以浪费的空间以及复制使用的开销会比较小。

在64位系统中一个`semisapce`为`16MB`，32位为`8MB`，所以新生代内存大小分别为`32MB`和`16MB`。

**老生代**

主要存放生存周期比较长的对象。内存按照`1MB`分页，并且都按照`1MB`对齐。新生代的内存是连续的，而老生代的内存是分散的，以链表的形式串联起来。

老生代的内部有4种类型：

