(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{359:function(t,s,v){"use strict";v.r(s);var _=v(42),e=Object(_.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"编译原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[t._v("#")]),t._v(" 编译原理")]),t._v(" "),v("blockquote",[v("p",[t._v("《编译系统透视：图解编译原理》读书笔记")])]),t._v(" "),v("h2",{attrs:{id:"c程序的运行式结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#c程序的运行式结构"}},[t._v("#")]),t._v(" C程序的运行式结构")]),t._v(" "),v("p",[t._v("C程序运行的核心是函数的执行和调用，它构成了整个C程序运行时结构的基础框架。这一运行过程主要是在程序指令的驱动以及数据压栈、清栈的支持下实现的。")]),t._v(" "),v("p",[t._v("以下面的程序为例：")]),t._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" m "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    m "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("fun")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    c"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("a"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("h3",{attrs:{id:"程序加载时的内存概况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序加载时的内存概况"}},[t._v("#")]),t._v(" 程序加载时的内存概况")]),t._v(" "),v("p",[t._v("运行时，在内存中，共有代码区、静态数据区和动态数据区三个区域。")]),t._v(" "),v("p",[v("img",{attrs:{src:"//img.haozhenjia.com/blog/code_memory.jpg",alt:"内存区域"}})]),t._v(" "),v("p",[t._v("其中，"),v("strong",[t._v("代码区")]),t._v("装载了程序所对应的机器指令；全局变量"),v("code",[t._v("m")]),t._v("的数值装载在"),v("strong",[t._v("静态数据区")]),t._v("中；"),v("strong",[t._v("动态数据区")]),t._v("加载程序运行过程中产生的数据。")]),t._v(" "),v("p",[t._v("程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。")]),t._v(" "),v("p",[v("code",[t._v("CPU")]),t._v("中有三个寄存器，分别是"),v("code",[t._v("eip")]),t._v("、"),v("code",[t._v("ebp")]),t._v("和"),v("code",[t._v("esp")]),t._v("。")]),t._v(" "),v("p",[v("code",[t._v("eip")]),t._v("永远指向代码区将要执行的下一条指令，它的管控方式有两种，一种是“顺序执行”，即程序执行完一条指令后自动指向下一条执行；另一种是跳转，也就是执行完一条跳转指令后跳转到指定的位置。")]),t._v(" "),v("p",[v("code",[t._v("ebp")]),t._v("和"),v("code",[t._v("esp")]),t._v("用来管控栈空间，"),v("code",[t._v("ebp")]),t._v("指向栈底，"),v("code",[t._v("esp")]),t._v("指向栈顶。在代码区中，函数调用、返回和执行伴随着不断压栈和清栈，栈中数据存储和释放的原则是后进先出。")]),t._v(" "),v("p",[v("code",[t._v("eip")]),t._v("指向"),v("code",[t._v("main")]),t._v("函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp和esp指向的位置是程序加载时内核设置的。")]),t._v(" "),v("h3",{attrs:{id:"程序运行过程中的内存变化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序运行过程中的内存变化"}},[t._v("#")]),t._v(" 程序运行过程中的内存变化")]),t._v(" "),v("p",[t._v("程序开始执行"),v("code",[t._v("main")]),t._v("函数第一条指令("),v("code",[t._v("call")]),t._v("指令)，"),v("code",[t._v("eip")]),t._v("自动指向下一条指令。第一条指令的执行，致使"),v("code",[t._v("ebp")]),t._v("的地址值被保存在栈中，保存的目的是本程序执行完毕后，"),v("code",[t._v("ebp")]),t._v("还能返回现在的位置，复原现在的栈。")]),t._v(" "),v("p",[t._v("随着"),v("code",[t._v("ebp")]),t._v("地址值的压栈，"),v("code",[t._v("esp")]),t._v("自动向栈顶方向移动，它将永远指向栈顶。")]),t._v(" "),v("p",[t._v("接下来，开始构建"),v("code",[t._v("main")]),t._v("函数自己的栈，"),v("code",[t._v("ebp")]),t._v("原来指向的地址值已经被保存了，此时和"),v("code",[t._v("esp")]),t._v("是重叠的，用来看管main函数的栈底。")]),t._v(" "),v("h2",{attrs:{id:"汇编中的寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#汇编中的寄存器"}},[t._v("#")]),t._v(" 汇编中的寄存器")]),t._v(" "),v("p",[v("code",[t._v("eax")]),t._v(", "),v("code",[t._v("ebx")]),t._v(", "),v("code",[t._v("ecx")]),t._v(", "),v("code",[t._v("edx")]),t._v(", "),v("code",[t._v("esi")]),t._v(", "),v("code",[t._v("edi")]),t._v(", "),v("code",[t._v("ebp")]),t._v(", "),v("code",[t._v("esp")]),t._v("等都是"),v("code",[t._v("X86")]),t._v("汇编语言中"),v("code",[t._v("CPU")]),t._v("上的通用寄存器的名称，是32位的寄存器。")]),t._v(" "),v("p",[t._v("如果用C语言来解释，可以把这些寄存器当作变量看待。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("汇编名称")]),t._v(" "),v("th",[t._v("寄存器类型")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("EAX")])]),t._v(" "),v("td",[t._v("累加寄存器"),v("code",[t._v("accumulator register")])]),t._v(" "),v("td",[t._v("加法乘法指令的缺省寄存器")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EBX")])]),t._v(" "),v("td",[t._v("基址寄存器"),v("code",[t._v("base register")])]),t._v(" "),v("td",[t._v("内存寻址时存放基地址")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ECX")])]),t._v(" "),v("td",[t._v("程序计数器"),v("code",[t._v("program counter")])]),t._v(" "),v("td",[t._v("重复"),v("code",[t._v("REP")]),t._v("前缀指令和"),v("code",[t._v("LOOP")]),t._v("指令的内定计数器")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EDX")])]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("用来存放整数除法产生的余数")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ESI")])]),t._v(" "),v("td",[t._v("源索引寄存器"),v("code",[t._v("source index")])]),t._v(" "),v("td",[t._v("在很多字符串操作指令中, "),v("code",[t._v("DS:ESI")]),t._v("指向源串")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EDI")])]),t._v(" "),v("td",[t._v("目标索引寄存器"),v("code",[t._v("destination index")])]),t._v(" "),v("td",[t._v("在很多字符串操作指令中, "),v("code",[t._v("ES:EDI")]),t._v("指向目标串")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EBP")])]),t._v(" "),v("td",[t._v("基址指针"),v("code",[t._v("base pointer")])]),t._v(" "),v("td",[t._v("常被用作高级语言函数调用的"),v("strong",[t._v("框架指针"),v("code",[t._v("frame pointer")])]),t._v("，存放当前线程的栈底指针")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ESP")])]),t._v(" "),v("td",[t._v("堆栈指针")]),t._v(" "),v("td",[t._v("存放当前线程的栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EIP")])]),t._v(" "),v("td",[t._v("指令寄存器"),v("code",[t._v("instrution register")])]),t._v(" "),v("td",[t._v("存放下一个"),v("code",[t._v("CPU")]),t._v("指令存放的内存地址")])])])]),t._v(" "),v("p",[t._v("因此，在函数的起始部分经常有：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("push ebp; 保存当前ebp\nmov ebp, esp; EBP设为当前堆栈指针\nsub esp, xxx; 预留xxx字节给函数临时变量.\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);